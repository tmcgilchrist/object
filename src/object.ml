(** Interface for reading object files *)
(* open Unsigned                   (\* TODO Move this into Types *\) *)

module Buffer = Buffer
(** Common memory-mapped buffer for reading and writing object files. *)

module Macho = Macho
(** Low-level Mach-O file format *)

module Elf = Elf
(** Low-level ELF file format *)

(* Common sizes of types being read and written. *)
(* open Types *)

(* TODO Common abstraction across executable formats. Is this possible or a good idea? *)
(* (\** A relocation entry. *\) *)
(* module Relocation = struct *)

(*   (\** The operation used to calculate the result of the relocation. *\) *)
(*   type relocation_kind = *)
(*     | Unknown *)
(*     | Absolute *)
(*     | Relative *)
(*     | Got *)
(*     | GotRelative *)
(*     | GotBaseRelative *)
(*     | GotBaseOffset *)
(*     | PltRelative *)
(*     | ImageOffset *)
(*     | SectionOffset *)
(*     | SectionIndex *)

(*   (\** Information about how the result of the relocation operation is encoded in the place. *)
(*       Typically architecture specific, such as specifying an addressing mode or a specific instruction. *)
(*    *\) *)
(*   type relocation_encoding = *)
(*     | Unknown *)
(*     | Generic                   (\* Generic encoding *\) *)
(*     | X86Signed                 (\* x86 sign extension at runtime *\) *)
(*     | X86RipRelative            (\* x86 rip-relative addressing. *\) *)
(*     | X86RipRelativeMovq        (\* x86 rip-relative addressing in movq instruction. *\) *)
(*     | X86Branch                 (\* x86 branch instruction. *\) *)
(*     | S390xDbl                  (\* s390x PC-relative offset shifted right by one bit. *\) *)
(*     | AArch64Call               (\* AArch64 call target. *\) *)

(*   type relocation_target = *)
(*     | Symbol of UInt32.t (\** The target is a symbol. *\) *)
(*     | Section of UInt32.t (\** The target is a section. *\) *)
(*     | Absolute (\** The offset is an absolute address. *\) *)

(*   type t = { *)
(*       kind : relocation_kind; *)
(*       encoding : relocation_encoding; *)
(*       size : UInt8.t; *)
(*       target : relocation_target; *)
(*     } *)
(* end *)

(* type sec_type =[ *)
(*   | `Unknown (\** The section kind is unknown. *\) *)
(*   | `Text    (\** An executable code section. *\) *)
(*   | `Data    (\** A data section. *\) *)
(*   | `ReadOnlyData (\** A read only data section. *\) *)
(*   | `ReadOnlyDataWithRel (\** A read only data section with relocations. *\) *)
(*   | `ReadOnlyString (\** A loadable string section. *\) *)
(*   | `UninitializedData (\** An uninitialized data section. *\) *)
(*   | `Common (\** An uninitialized common data section. *\) *)
(*   | `Tls    (\** A TLS data section. *\) *)
(*   | `UninitializedTls (\** An uninitialized TLS data section. *\) *)
(*   | `TlsVariables     (\** A TLS variables section. *\) *)
(*   | `OtherString (\** A non-loadable string section. *\) *)
(*   | `Other (\** Some other non-loadable section. *\) *)
(*   | `Debug (\** Debug information. *\) *)
(*   | `DebugString (\** Debug strings. *\) *)
(*   | `Linker (\** Information for the linker. *\) *)
(*   | `Note (\** ELF note section. *\) *)
(*   | `Metadata (\** Metadata such as symbols or relocations. *\) *)
(*   | `Elf of UInt32.t (\** Some other ELF section type.  *\) *)
(*   ] *)

(* (\** A section in an {!Object.t}. *\) *)
(* module ObjectSection = struct *)
(*   type t = { *)
(*       index : UInt64.t; *)
(*       (\** The section index *\) *)
(*       address : UInt64.t; *)
(*       (\** The address of the section *\) *)
(*       size : UInt64.t; *)
(*       (\** The size of the section in memory *\) *)
(*       align : UInt64.t; *)
(*       (\** Alignment required by section (literal form, not power of two, e.g. 8 not 3) *\) *)
(*       name   : string; *)
(*       (\** Name of section *\) *)
(*       segment_name   : string; *)
(*       (\** name of segment that should own this section *\) *)

(*       (\* size of section *\) *)
(*       sec_size       : u64; *)
(*       (\* relocations for this section *\) *)
(*       sec_relocs     : Relocation.t array; *)
(*       (\* type of section *\) *)
(*       sec_type       : sec_type; *)

(*       (\* TODO Mach-O specific  *\) *)
(*       (\* (\\* user attributes of section *\\) *\) *)
(*       (\* sec_user_attrs : sec_user_attr list; *\) *)
(*       (\* (\\* system attributes of section *\\) *\) *)
(*       (\* sec_sys_attrs  : sec_sys_attr list; *\) *)
(*     } *)
(* end *)

(* type seg_flag = *)
(*   | None *)
(*   (\** No segment flags. *\) *)
(*   | Elf of { p_flags: UInt32.t (\** [p_flags] field in the segment header.*\) } *)
(*   (\** Elf segment flags *\) *)
(*   | MachO of { flags: UInt32.t; maxprot: UInt32.t; initprot: UInt32.t } *)

(* (\** A loadable segment in an {!Object.t}. *\) *)
(* module ObjectSegment = struct *)
(*   type t = { *)
(*       (\* The virtual address of the segment *\) *)
(*       address : UInt64.t; *)
(*       (\* The size of the segment in memory *\) *)
(*       size    : UInt64.t; *)
(*       (\* The alignment of the segment in memory *\) *)
(*       align   : UInt64.t; *)
(*       (\* The offset and size of the segment in the file *\) *)
(*       file_range : UInt64.t * UInt64.t; *)
(*       (\* The name of the segment *\) *)
(*       name : string; *)
(*       (\* The flags of the segment *\) *)
(*       flags : seg_flag list; *)
(*       (\* The sections within the segment *\) *)
(*       sections: ObjectSection.t array; *)
(*     } *)
(* end *)

(* (\** A symbol table entry in an {!Object.t}. *\) *)
(* module ObjectSymbol = struct *)
(* end *)

(* (\** A symbol table in an {!Object.t}. *\) *)
(* module ObjectSymbolTable = struct *)
(* end *)

(* (\** An entry in a {!SymbolMap}. *\) *)
(* module SymbolMapEntry = struct *)
(* end *)

(* (\** A map from addresses to symbol information. *\) *)
(* module SymbolMap = struct *)
(*   type t *)
(* end *)

(* (\** The size of an address value for an architecture. *\) *)
(* module AddressSize = struct *)
(*   type t = *)
(*     | U8 *)
(*     | U16 *)
(*     | U32 *)
(*     | U64 *)

(*   let bytes : t -> u8 = function *)
(*     | U8 -> 1 *)
(*     | U16 -> 2 *)
(*     | U32 -> 4 *)
(*     | U64 -> 8 *)
(* end *)

(* (\** A binary file format. *\) *)

(* type binary_format = *)
(*   | Coff *)
(*   | Elf *)
(*   | MachO *)
(*   | Pe *)

(* (\** An object file. *\) *)
(* module Object = struct *)
(*   type t *)
(* end *)
